# Гауссово размытие без использования сторонних библиотек

## Алгоритм работы

Двумерное гауссово размытие можно представить как суперпозицию двух одномерных.
Это сильно облегчает возможности для распараллеливания.

Мы строим линейный вектор коэффициентов для свёртки, в окне радиусом 3 сигмы.
3 сигмы - это примерно 0.1% на концах, что меньше динамического диапазона (255 уровней в канале).
Можно было искать радиус вручную, но и так сойдёт.

Поскольку радиус - в пикселях, то округляем вверх.
Итого размер вектора - 2r + 1 = 6s + 1 (+1 это центральный пиксель).

Вектор нормирован, в сумме = 1.
Нормировка делается вручную, - во-первых, чтобы не "1/sqrt(2pi*sigma^2)",
а во-вторых, чтобы убрать любые ошибки округления, хоть мы и в 3 сигмах.

Для каждой сканлинии (строки или столбца битмапа) слева и справа добавляем
одинаковые пиксели в количестве радиус штук, равные краевым пикселям.
Это нужно, чтобы цвет пикселя после размытия был "естественным", а не белым-чёрным-прозрачным и т.п.

Размытие сканлинии - это свёртка её пикселей с вектором коэффициентов.
На входе - расширенная сканлиния, на выходе - точно в размер линии битмапа.

Поскольку свёртки сканлиний не влияют друг на друга, они выполняются параллельно.

Два этапа: сперва по строкам, и строго за тем - по столбцам.
(Можно наоборот, непринципиально).

## Размещение в памяти

Для экономии памяти, битмап не копируется, а перезаписывается.

Поскольку нельзя просто так взять и расшарить битмап между воркерами,
то мы вынуждены копировать каждую сканлинию.

Также мы не можем просто так взять и перезаписывать сканлинию во время свёртки.
(Ну то есть, можем, но там получится хитроумное уравнение и набежит погрешность).

Таким образом, полный расход памяти - это
- сам битмап, из которого мы извлекаем сканлинии и куда записываем их обратно
- исходные сканлинии (эквивалент битмапа с полями по горизонтали либо вертикали)
- полученные сканлинии (эквивалент битмапа)

Через границу потоков (между окном и воркерами) битмап и-или сканлинии передаются
не копированием, а перемещением (transfer), это экономит память,
но это семантика монопольного владения и временных данных.

Перезапись битмапа также означает семантику монопольного владения.
Нельзя просто так взять и вызвать функцию размытия несколько раз к одному битмапу!

## Параллелизм

Ради эксперимента, сделал тремя разными способами.
- просто запихал функцию целиком во внешний поток (TODO: пробросить индикатор прогресса)
- запускаю поток для каждой функции свёртки сканлинии - это чертовски невыгодно, поскольку быстро создаётся гора потоков
- (TODO для улучшения - сделать ограничение на количество одновременно созданных)
- фиксированный пул потоков с протоколом общения: передаю коэффициенты один раз на старте, затем каждый запрос - это свёртка какой-то сканлинии, уникально идентифицированной.
- (TODO ограничивать количество запросов, сейчас они все сразу валятся в системную очередь)

Адаптивный способ - для маленьких картинок запускает однопоточную версию, для больших пул потоков.

## Стиль кода

Предпочёл экмаскрипт с модулями, потому что не разобрался, как красиво делать импорты без них.

Каждый способ оформлен как модуль, в котором есть клиентская функция и тело воркера.
Воркер запускается отдельным модулем, все эти body.ts выглядят одинаково.
Наверное, можно наколдовать в виде сериализации скрипта в урл... (TODO попробовать)

Битмап и сканлинии представлены сырыми байтовыми массивами - и функциями доступа к ним.
(TODO сделать прокси-классы).

Функции высшего порядка - по необходимости. Колбеки там передавать всякие.
Если честно, то не хотел преждевременно нормализовать код в ущерб наглядности, а возможно, что и в ущерб производительности.
(TODO обобщить обработку столбцов и строк)

## Сторонняя библиотека

Вот эта гиря node_modules - это стандартный http-server.
Я не виноват, что `npm install http-server` втянул такую гирю.

## http-сервер

Сайт статический. Он состоит из двух каталогов
- /html/main.html
- /distrib/**/*.js

Но просто сохранить и открывать в схеме `file://` нельзя, у браузера сработает защита.
Надо запустить вебсервер (самый тупой, `npm run http-server` прописан в package.json).

## Порядок работы

0. Запустить веб-сервер!!!
1. Загрузить файл (кнопка Load file...) или указать урл картинки и нажать "Load!"
2. Дождаться изображения
3. Установить желаемые параметры размытия (сигму и технические детали реализации)
4. Нажать "Blur"
5. Дождаться второго изображения. Прогресс работы показан в отдельной строчке.

## Структура каталогов

- html
  - main.html - главная и единственная страничка
- src - исходники на typescript
  - main - скрипт для main.html
  - dom - то, что требует HTML DOM (выполняется в контексте страницы)
  - workers - то, что требует WebWorkers
- tsmain - фейковый корневой проект typescript, который подтягивает остальные по зависимостям
- distrib - сюда генереруются javascript-файлы, структура совпадает с src


## Порядок сборки

Убедиться, что в системе есть node.js и typescript.

Я не смог полноценно настроить окружение в Win11, пошёл простым путём - установил dev-container в WSL,
контейнер называется `typescript-node`, полное имя
`mcr.microsoft.com/devcontainers/typescript-node:1-22-bookworm`
(TODO - сделать герметичный докер приложения, научить его вешаться на нужный порт и всё такое)

Выполнить сборку `npm run build` = `tsc -b tsmain`
